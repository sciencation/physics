<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <title>二原子分子の運動モード可視化</title>
    <style>
        body {
            background-color: #1a1a1a;
            color: #f0f0f0;
            font-family: 'Helvetica Neue', Arial, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            margin: 0;
            padding: 20px;
        }
        h2 { margin-bottom: 10px; }
        .container {
            position: relative;
            box-shadow: 0 0 20px rgba(0,0,0,0.5);
        }
        canvas {
            background-color: #000;
            border-radius: 4px;
            cursor: grab;
        }
        canvas:active {
            cursor: grabbing;
        }
        .controls {
            margin-top: 15px;
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 15px;
            width: 480px;
        }
        .control-group {
            background: #333;
            padding: 10px;
            border-radius: 8px;
            text-align: center;
            display: flex;
            flex-direction: column;
            gap: 5px;
        }
        .control-group h3 {
            margin: 0 0 5px 0;
            font-size: 14px;
            color: #aaa;
            border-bottom: 1px solid #444;
            padding-bottom: 5px;
        }
        button {
            background: #555;
            color: white;
            border: none;
            padding: 10px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.2s;
        }
        button:hover { background: #666; }
        button.active { background: #007bff; box-shadow: 0 0 8px #007bff; }
        button#btnRot1.active { background: #e91e63; box-shadow: 0 0 8px #e91e63; } /* Pink for Axis 1 */
        button#btnRot2.active { background: #00bcd4; box-shadow: 0 0 8px #00bcd4; } /* Cyan for Axis 2 */
        button#btnRot3.active { background: #ffeb3b; box-shadow: 0 0 8px #ffeb3b; color: #333; } /* Yellow for Axis 3 */
        button.mode-btn { font-size: 12px; padding: 8px; }
        
        .description {
            margin-top: 20px;
            max-width: 640px;
            line-height: 1.6;
            background: #2a2a2a;
            padding: 20px;
            border-radius: 8px;
            font-size: 0.95em;
            border-left: 5px solid #007bff;
        }
        .key-point {
            font-weight: bold;
            color: #fff;
        }
        ul { padding-left: 20px; margin: 10px 0; }
        li { margin-bottom: 5px; }
    </style>
</head>
<body>
    <h2>分子の内部エネルギー：回転と振動モード</h2>
    
    <div class="container">
        <canvas id="simCanvas" width="480" height="360"></canvas>
    </div>

    <div class="controls">
        <div class="control-group">
            <h3>分子タイプ</h3>
            <button id="btnTypeDi" class="active" onclick="setMoleculeType('diatomic')">二原子 (N<sub>2</sub>)</button>
            <button id="btnTypeTri" onclick="setMoleculeType('triatomic')">直線三原子 (CO<sub>2</sub>)</button>
            <button id="btnTypeBent" onclick="setMoleculeType('bent')">非直線三原子 (H<sub>2</sub>O)</button>
        </div>
        <div class="control-group">
            <h3 id="rotHeader">回転 (Rotation)</h3>
            <button id="btnRot1" onclick="toggleRot1()">回転軸 1 (Y軸)</button>
            <button id="btnRot2" onclick="toggleRot2()">回転軸 2 (Z軸)</button>
            <button id="btnRot3" onclick="toggleRot3()" style="display:none;">回転軸 3 (X軸)</button>
        </div>
        <div class="control-group">
            <h3>振動 (Vibration)</h3>
            <div id="vibControlsDi">
                <button id="btnVib" onclick="toggleVib()">伸縮振動</button>
            </div>
            <div id="vibControlsTri" style="display:none; flex-direction:column; gap:5px;">
                <button class="mode-btn" id="btnVibSym" onclick="toggleVibMode('sym')">対称伸縮</button>
                <button class="mode-btn" id="btnVibAsym" onclick="toggleVibMode('asym')">逆対称伸縮</button>
                <button class="mode-btn" id="btnVibBend" onclick="toggleVibMode('bend')">変角振動</button>
            </div>
        </div>
        <div class="control-group">
            <h3>シミュレーション操作</h3>
            <button onclick="resetSim()">リセット (停止)</button>
            <button onclick="toggleAll()">全部盛り (All)</button>
        </div>
    </div>

    <div class="description" style="max-width: 480px;">
        <p>分子が持つ内部エネルギーの運動モードを可視化しています。</p>
        <ul>
            <li><span class="key-point">回転運動</span>：<br>
                直線状の分子（N<sub>2</sub>, CO<sub>2</sub>）は2つの回転自由度を持ちますが、分子軸方向（串刺し方向）の回転は慣性モーメントが無視できるためエネルギーになりません。<br>
                一方、非直線型分子（H<sub>2</sub>O）は3つの軸すべてに対して慣性モーメントを持つため、<span class="key-point" style="color:#ffeb3b">3つの回転自由度</span>を持ちます。</li>
            <li><span class="key-point" style="color:#4caf50">振動モード</span>：<br>
                原子間の結合がバネのように振動する運動です。多原子分子では「対称伸縮」「逆対称伸縮」「変角振動」などのモードが存在します。</li>
        </ul>
        <p style="font-size: 0.85em; color: #888;">※ マウスドラッグで視点を回転できます。</p>
    </div>

<script>
    // ==========================================
    // 3D Vector & Quaternion Math Helpers
    // ==========================================
    const Vec3 = {
        add: (v1, v2) => ({ x: v1.x + v2.x, y: v1.y + v2.y, z: v1.z + v2.z }),
        scale: (v, s) => ({ x: v.x * s, y: v.y * s, z: v.z * s }),
        rotateX: (v, angle) => {
            const c = Math.cos(angle), s = Math.sin(angle);
            return { x: v.x, y: v.y * c - v.z * s, z: v.y * s + v.z * c };
        },
        rotateY: (v, angle) => {
            const c = Math.cos(angle), s = Math.sin(angle);
            return { x: v.x * c + v.z * s, y: v.y, z: -v.x * s + v.z * c };
        }
    };

    const Quat = {
        identity: () => ({ w: 1, x: 0, y: 0, z: 0 }),
        multiply: (q1, q2) => ({
            w: q1.w * q2.w - q1.x * q2.x - q1.y * q2.y - q1.z * q2.z,
            x: q1.w * q2.x + q1.x * q2.w + q1.y * q2.z - q1.z * q2.y,
            y: q1.w * q2.y - q1.x * q2.z + q1.y * q2.w + q1.z * q2.x,
            z: q1.w * q2.z + q1.x * q2.y - q1.y * q2.x + q1.z * q2.w
        }),
        fromAxisAngle: (axis, angle) => {
            const half = angle / 2;
            const s = Math.sin(half);
            return { w: Math.cos(half), x: axis.x * s, y: axis.y * s, z: axis.z * s };
        },
        applyToVec: (v, q) => {
            // v' = q * v * q_conjugate
            const ix = q.w * v.x + q.y * v.z - q.z * v.y;
            const iy = q.w * v.y + q.z * v.x - q.x * v.z;
            const iz = q.w * v.z + q.x * v.y - q.y * v.x;
            const iw = -q.x * v.x - q.y * v.y - q.z * v.z;
            return {
                x: ix * q.w + iw * -q.x + iy * -q.z - iz * -q.y,
                y: iy * q.w + iw * -q.y + iz * -q.x - ix * -q.z,
                z: iz * q.w + iw * -q.z + ix * -q.y - iy * -q.x
            };
        },
        normalize: (q) => {
            const len = Math.sqrt(q.w*q.w + q.x*q.x + q.y*q.y + q.z*q.z);
            if (len === 0) return { w:1, x:0, y:0, z:0 };
            return { w: q.w/len, x: q.x/len, y: q.y/len, z: q.z/len };
        }
    };

    // ==========================================
    // Simulation State
    // ==========================================
    const canvas = document.getElementById('simCanvas');
    const ctx = canvas.getContext('2d');

    // Molecule Properties
    let molecule = {
        type: 'diatomic',             // 'diatomic' or 'triatomic'
        orientation: Quat.identity(), // Current rotation in world space
        baseLength: 140,              // Equilibrium bond length (distance from center)
        atomRadius: 30,
        color: '#4a90e2'
    };

    // Animation State
    let state = {
        rot1: false, // Rotation around local Y axis
        rot2: false, // Rotation around local Z axis
        rot3: false, // Rotation around local X axis (for non-linear)
        vibStretch: false, // For diatomic
        vibSym: false,     // For polyatomic
        vibAsym: false,    // For polyatomic
        vibBend: false,    // For polyatomic
        time: 0
    };

    // Camera / View
    let camera = {
        angleX: 0, // Pitch
        angleY: 0, // Yaw
        dist: 400
    };

    // Constants
    const ROT_SPEED = 0.03;
    const VIB_SPEED = 0.2;
    const VIB_AMP = 30;

    // ==========================================
    // Update Logic
    // ==========================================
    function update() {
        state.time += 1;

        // 2. Handle Rotation
        // We apply rotation in the molecule's LOCAL frame
        // Local X is the bond axis. Local Y and Z are the rotation axes.
        let deltaQ = Quat.identity();
        
        if (state.rot1) {
            // Rotate around Local Y
            const qY = Quat.fromAxisAngle({x:0, y:1, z:0}, ROT_SPEED);
            deltaQ = Quat.multiply(deltaQ, qY);
        }
        if (state.rot2) {
            // Rotate around Local Z
            const qZ = Quat.fromAxisAngle({x:0, y:0, z:1}, ROT_SPEED * 1.3); // Slightly different speed
            deltaQ = Quat.multiply(deltaQ, qZ);
        }
        if (state.rot3) {
            // Rotate around Local X
            const qX = Quat.fromAxisAngle({x:1, y:0, z:0}, ROT_SPEED * 0.9);
            deltaQ = Quat.multiply(deltaQ, qX);
        }

        // Update orientation: NewOrientation = OldOrientation * DeltaRotation_Local
        molecule.orientation = Quat.multiply(molecule.orientation, deltaQ);
        molecule.orientation = Quat.normalize(molecule.orientation);
    }

    // Calculate atom positions in Local Space based on current state
    function getLocalAtoms() {
        const atoms = [];
        const t = state.time;
        const L = molecule.baseLength;
        
        // Vibration offsets
        let d1 = 0, d2 = 0, dy = 0;
        
        const phase = t * VIB_SPEED;

        if (molecule.type === 'diatomic') {
            if (state.vibStretch) {
                d1 = Math.sin(phase) * VIB_AMP;
            }
        } else { // triatomic or bent
            // Superposition of modes with slightly different frequencies
            if (state.vibSym) {
                d1 += Math.sin(phase) * VIB_AMP; 
            }
            if (state.vibAsym) {
                d2 += Math.sin(phase * 1.1) * VIB_AMP; // Slightly different freq
            }
            if (state.vibBend) {
                dy += Math.sin(phase * 0.7) * (VIB_AMP * 0.8); // Slower freq
            }
        }

        if (molecule.type === 'diatomic') {
            // Two atoms centered at origin
            const currentLen = (L * 2) + d1; // baseLength is half-length effectively in previous logic, but let's adjust
            // Let's say baseLength is distance from center for triatomic. 
            // For diatomic, let's keep it simple: distance is 2*L_eff
            const half = (150 + d1) / 2;
            
            atoms.push({ x:  half, y: 0, z: 0, color: molecule.color });
            atoms.push({ x: -half, y: 0, z: 0, color: molecule.color });
        } else if (molecule.type === 'triatomic') {
            // Triatomic (Linear): O - C - O
            // Center atom (C)
            // Outer atoms (O)
            const cColor = '#333'; // Carbon
            const oColor = '#ff5252'; // Oxygen

            // Atom 1 (Right)
            // Sym: +d1, Asym: +d2, Bend: y moves
            atoms.push({ x:  L + d1 + d2, y: -dy, z: 0, color: oColor });
            
            // Atom 2 (Left)
            // Sym: -d1 (opposite), Asym: +d2 (same direction shift), Bend: y moves
            atoms.push({ x: -L - d1 + d2, y: -dy, z: 0, color: oColor });

            // Atom 3 (Center)
            // Conservation of momentum approximations
            // Asym: Center moves opposite to outer atoms
            // Bend: Center moves opposite in Y
            atoms.push({ x: -2 * d2 * 0.5, y: 2 * dy * 0.5, z: 0, color: cColor });
        } else if (molecule.type === 'bent') {
            // Water (H2O): H - O - H
            // Bent shape. Let's define in XY plane.
            // Equilibrium angle ~104.5 deg. Half angle ~52 deg.
            const angleBase = 52 * Math.PI / 180;
            
            // Vibration effects
            // Sym: Both arms lengthen/shorten (d1)
            // Asym: One lengthens, one shortens (d2)
            // Bend: Angle changes (dy affects angle)
            
            const L_eq = 100; // Equilibrium bond length
            const L1 = L_eq + d1 + d2;
            const L2 = L_eq + d1 - d2;
            
            // Angle change for bending
            const angleChange = (dy / 50); // Map dy to angle change
            const angle = angleBase + angleChange;

            const hColor = '#eeeeee'; // Hydrogen
            const oColor = '#ff5252'; // Oxygen

            // Center O at origin
            // Note: For strict physics, we should rotate around Center of Mass, but for visualization, O at center is clearer.
            atoms.push({ x: 0, y: 0, z: 0, color: oColor }); // Oxygen (Center)
            atoms.push({ x: L1 * Math.cos(angle), y: L1 * Math.sin(angle), z: 0, color: hColor }); // H1
            atoms.push({ x: L2 * Math.cos(angle), y: -L2 * Math.sin(angle), z: 0, color: hColor }); // H2
        }
        return atoms;
    }

    // ==========================================
    // Drawing Logic
    // ==========================================
    function project(v) {
        // 1. Rotate by Camera
        let p = Vec3.rotateY(v, camera.angleY);
        p = Vec3.rotateX(p, camera.angleX);
        
        // 2. Perspective Projection
        const fov = 500;
        const scale = fov / (fov + p.z + camera.dist);
        
        return {
            x: canvas.width / 2 + p.x * scale,
            y: canvas.height / 2 + p.y * scale,
            scale: scale,
            z: p.z // Keep Z for sorting
        };
    }

    function draw() {
        // Clear background
        ctx.fillStyle = '#111';
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        // Get Atoms
        const localAtoms = getLocalAtoms();
        
        // Transform and Project
        const projectedAtoms = localAtoms.map(atom => {
            const world = Quat.applyToVec(atom, molecule.orientation);
            const proj = project(world);
            return { ...proj, color: atom.color };
        });

        // Draw Axes (Visual Guides) if rotation is active
        if (state.rot1 || state.rot2 || state.rot3) {
            drawAxes(molecule.orientation);
        }

        // Draw Bonds
        // Connect atoms. Diatomic: 0-1. Triatomic: 2-0 and 2-1 (2 is center)
        const bonds = [];
        if (molecule.type === 'diatomic') {
            bonds.push([0, 1]);
        } else if (molecule.type === 'triatomic') {
            bonds.push([2, 0]); // Center(2) to Outer(0)
            bonds.push([2, 1]); // Center(2) to Outer(1)
        } else if (molecule.type === 'bent') {
            bonds.push([0, 1]); // Center(0) to H1(1)
            bonds.push([0, 2]); // Center(0) to H2(2)
        }

        bonds.forEach(pair => {
            const p1 = projectedAtoms[pair[0]];
            const p2 = projectedAtoms[pair[1]];
            drawBond(p1, p2);
        });

        // Draw Atoms (Painter's Algorithm: Draw furthest first)
        projectedAtoms.sort((a, b) => b.z - a.z); // Sort by Z (descending)

        projectedAtoms.forEach(atom => {
            const r = molecule.atomRadius * atom.scale;
            
            // Sphere gradient
            const grad = ctx.createRadialGradient(
                atom.x - r*0.3, atom.y - r*0.3, r * 0.1,
                atom.x, atom.y, r
            );
            grad.addColorStop(0, '#fff');
            grad.addColorStop(0.3, atom.color);
            grad.addColorStop(1, '#003366');

            ctx.beginPath();
            ctx.arc(atom.x, atom.y, r, 0, Math.PI * 2);
            ctx.fillStyle = grad;
            ctx.fill();
        });
    }

    function drawBond(p1, p2) {
        ctx.beginPath();
        ctx.moveTo(p1.x, p1.y);
        ctx.lineTo(p2.x, p2.y);
        ctx.lineWidth = 12 * ((p1.scale + p2.scale) / 2);
        ctx.strokeStyle = '#888';
        ctx.lineCap = 'round';
        ctx.stroke();
    }

    function drawAxes(orientation) {
        // Local axes vectors
        const axisLen = 120;
        const origin = {x:0, y:0, z:0};
        const yAxis_local = {x:0, y:axisLen, z:0};
        const zAxis_local = {x:0, y:0, z:axisLen};
        const xAxis_local = {x:axisLen, y:0, z:0};

        // Transform to world
        const yAxis_world = Quat.applyToVec(yAxis_local, orientation);
        const zAxis_world = Quat.applyToVec(zAxis_local, orientation);
        const xAxis_world = Quat.applyToVec(xAxis_local, orientation);

        const pOrigin = project(origin);
        const pY = project(yAxis_world);
        const pZ = project(zAxis_world);
        const pX = project(xAxis_world);

        ctx.lineWidth = 2;

        // Draw Axis 1 (Local Y) - Pink
        if (state.rot1) {
            ctx.beginPath();
            ctx.moveTo(pOrigin.x, pOrigin.y);
            ctx.lineTo(pY.x, pY.y);
            ctx.strokeStyle = '#e91e63';
            ctx.setLineDash([5, 3]);
            ctx.stroke();
            ctx.setLineDash([]);
            
            // Label
            ctx.fillStyle = '#e91e63';
            ctx.font = '12px Arial';
            ctx.fillText('Axis 1', pY.x, pY.y);
        }

        // Draw Axis 2 (Local Z) - Cyan
        if (state.rot2) {
            ctx.beginPath();
            ctx.moveTo(pOrigin.x, pOrigin.y);
            ctx.lineTo(pZ.x, pZ.y);
            ctx.strokeStyle = '#00bcd4';
            ctx.setLineDash([5, 3]);
            ctx.stroke();
            ctx.setLineDash([]);

            // Label
            ctx.fillStyle = '#00bcd4';
            ctx.font = '12px Arial';
            ctx.fillText('Axis 2', pZ.x, pZ.y);
        }

        // Draw Axis 3 (Local X) - Yellow
        if (state.rot3) {
            ctx.beginPath();
            ctx.moveTo(pOrigin.x, pOrigin.y);
            ctx.lineTo(pX.x, pX.y);
            ctx.strokeStyle = '#ffeb3b';
            ctx.setLineDash([5, 3]);
            ctx.stroke();
            ctx.setLineDash([]);

            // Label
            ctx.fillStyle = '#ffeb3b';
            ctx.font = '12px Arial';
            ctx.fillText('Axis 3', pX.x, pX.y);
        }
    }

    // ==========================================
    // Loop & Controls
    // ==========================================
    function loop() {
        update();
        draw();
        requestAnimationFrame(loop);
    }

    // Button Handlers
    function setMoleculeType(type) {
        molecule.type = type;
        resetSim();
        
        // Update UI
        document.getElementById('btnTypeDi').className = type === 'diatomic' ? 'active' : '';
        document.getElementById('btnTypeTri').className = type === 'triatomic' ? 'active' : '';
        document.getElementById('btnTypeBent').className = type === 'bent' ? 'active' : '';
        
        const vibDi = document.getElementById('vibControlsDi');
        const vibTri = document.getElementById('vibControlsTri');
        const btnRot3 = document.getElementById('btnRot3');
        const rotHeader = document.getElementById('rotHeader');
        
        if (type === 'diatomic') {
            vibDi.style.display = 'block';
            vibTri.style.display = 'none';
            btnRot3.style.display = 'none';
            rotHeader.textContent = '回転 (Rotation) - 2自由度';
        } else {
            vibDi.style.display = 'none';
            vibTri.style.display = 'flex';
            btnRot3.style.display = (type === 'bent') ? 'inline-block' : 'none';
            rotHeader.textContent = (type === 'bent') ? '回転 (Rotation) - 3自由度' : '回転 (Rotation) - 2自由度';
        }
    }

    function toggleRot1() {
        state.rot1 = !state.rot1;
        updateButtons();
    }
    function toggleRot2() {
        state.rot2 = !state.rot2;
        updateButtons();
    }
    function toggleRot3() {
        state.rot3 = !state.rot3;
        updateButtons();
    }
    function toggleVib() {
        state.vibStretch = !state.vibStretch;
        updateButtons();
    }
    function toggleVibMode(mode) {
        // Toggle individual modes
        if (mode === 'sym') state.vibSym = !state.vibSym;
        if (mode === 'asym') state.vibAsym = !state.vibAsym;
        if (mode === 'bend') state.vibBend = !state.vibBend;
        updateButtons();
    }

    function resetSim() {
        state.rot1 = false;
        state.rot2 = false;
        state.rot3 = false;
        state.vibStretch = false;
        state.vibSym = false;
        state.vibAsym = false;
        state.vibBend = false;
        molecule.orientation = Quat.identity();
        camera.angleX = 0;
        camera.angleY = 0;
        updateButtons();
    }
    function toggleAll() {
        state.rot1 = true;
        state.rot2 = true;
        if (molecule.type === 'bent') state.rot3 = true;
        
        if (molecule.type === 'diatomic') {
            state.vibStretch = true;
        } else {
            state.vibSym = true;
            state.vibAsym = true;
            state.vibBend = true;
        }
        updateButtons();
    }

    function updateButtons() {
        document.getElementById('btnRot1').className = state.rot1 ? 'active' : '';
        document.getElementById('btnRot2').className = state.rot2 ? 'active' : '';
        document.getElementById('btnRot3').className = state.rot3 ? 'active' : '';
        
        if (molecule.type === 'diatomic') {
            document.getElementById('btnVib').className = state.vibStretch ? 'active' : '';
        } else {
            document.getElementById('btnVibSym').className = state.vibSym ? 'active' : '';
            document.getElementById('btnVibAsym').className = state.vibAsym ? 'active' : '';
            document.getElementById('btnVibBend').className = state.vibBend ? 'active' : '';
        }
    }

    // Mouse Interaction (Orbit Camera)
    let isDragging = false;
    let lastX, lastY;

    canvas.addEventListener('mousedown', e => {
        isDragging = true;
        lastX = e.clientX;
        lastY = e.clientY;
    });

    window.addEventListener('mousemove', e => {
        if (!isDragging) return;
        const dx = e.clientX - lastX;
        const dy = e.clientY - lastY;
        
        camera.angleY += dx * 0.01;
        camera.angleX += dy * 0.01;
        
        lastX = e.clientX;
        lastY = e.clientY;
    });

    window.addEventListener('mouseup', () => {
        isDragging = false;
    });

    // Initialize UI to match initial molecule type
    setMoleculeType('diatomic');
    
    // Start
    loop();

</script>
</body>
</html>
